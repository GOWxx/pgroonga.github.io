# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-24 12:18+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../../reference/operators/exact-match-search.md:1
msgid "---\n"
"title: \"&= operator\"\n"
"upper_level: ../\n"
"---"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:6
msgid "# `&=` operator"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:8
msgid "Since 2.4.6."
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:10
msgid "## Summary"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:12
msgid "`&=` operator performs exact match search."
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:14
msgid "## Syntax"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:16
msgid "```sql\n"
"column &= keyword\n"
"column &= (keyword, NULL, index_name)::pgroonga_full_text_search_condition\n"
"```"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:21
msgid "The first syntax does not use normally."
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:23
msgid "The second syntax is for using custom normalizer even if PGroonga's index is used or not."
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:25
msgid "Here is the description of the first signature."
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:27
msgid "```sql\n"
"column &= keyword\n"
"```"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:31
#: ../../../../reference/operators/exact-match-search.md:43
msgid "`column` is a column to be searched. It's `text` type or `varchar` type."
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:33
#: ../../../../reference/operators/exact-match-search.md:45
msgid "`keyword` is a keyword for exact match search . It's `text` type."
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:35
msgid "The operator returns `true` when the `column` exact match with `keyword`."
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:37
msgid "Here is the description of the second signature."
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:39
msgid "```sql\n"
"column &= (keyword, NULL, index_name)::pgroonga_full_text_search_condition\n"
"```"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:47
msgid "The second argument is set only NULL. Because this syntax is not for optimizing search score."
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:49
msgid "`index_name` is an index name of the corresponding PGroonga index. It's `text` type."
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:51
msgid "It's for using the same search options specified in PGroonga index in sequential search."
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:53
msgid "## Operator classes"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:55
msgid "We need to specify one of the following operator classes to use this operator:"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:57
msgid "  * `pgroonga_text_term_search_ops_v2`: For `text`"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:59
msgid "  * `pgroonga_varchar_term_search_ops_v2`: For `varchar`"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:61
msgid "## Usage"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:63
msgid "If PostgreSQL use PGroonga's index as below, `&=` operator can use custom normalizer."
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:65
msgid "Therefore, PostgreSQL returns 2 records(Groonga and groonga) by the search keyword like `gr-oonga` in the following example."
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:67
#: ../../../../reference/operators/exact-match-search.md:107
#: ../../../../reference/operators/exact-match-search.md:145
msgid "```sql\n"
"CREATE TABLE tags (\n"
"  id int,\n"
"  name text\n"
");"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:73
#: ../../../../reference/operators/exact-match-search.md:113
msgid "CREATE INDEX pgrn_index ON tags\n"
"  USING pgroonga (name pgroonga_text_term_search_ops_v2)\n"
"  WITH (normalizers='NormalizerNFKC150(\"remove_symbol\", true)');"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:77
#: ../../../../reference/operators/exact-match-search.md:117
#: ../../../../reference/operators/exact-match-search.md:154
msgid "INSERT INTO tags VALUES (1, 'PostgreSQL');\n"
"INSERT INTO tags VALUES (2, 'Groonga');\n"
"INSERT INTO tags VALUES (3, 'groonga');\n"
"INSERT INTO tags VALUES (4, 'PGroonga');"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:82
msgid "EXPLAIN (COSTS OFF)\n"
"SELECT name\n"
"  FROM tags\n"
" WHERE name &= 'gr-oonga';\n"
"QUERY PLAN\n"
"Bitmap Heap Scan on tags\n"
"   Recheck Cond: (name &= 'gr-oonga'::text)\n"
"   ->  Bitmap Index Scan on pgrn_index\n"
"         Index Cond: (name &= 'gr-oonga'::text)\n"
"(4 rows)"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:93
msgid "SELECT name\n"
"  FROM tags\n"
" WHERE name &= 'gr-oonga';\n"
"--    name    \n"
"-- -----------\n"
"--  PGroonga\n"
"--  pglogical\n"
"-- (2 rows)\n"
"```"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:103
msgid "However, if PostgreSQL does not use PGroonga's index, `&=` operator can not use custom normalizer."
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:105
msgid "Therefore, PostgreSQL returns no record by the search keyword like `gr-oonga` in the following example."
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:122
#: ../../../../reference/operators/exact-match-search.md:159
msgid "SET enable_seqscan = on;\n"
"SET enable_indexscan = off;\n"
"SET enable_bitmapscan = off;"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:126
msgid "EXPLAIN (COSTS OFF)\n"
"SELECT name\n"
"  FROM tags\n"
" WHERE name &= 'gr-oonga';\n"
"QUERY PLAN\n"
"Seq Scan on tags\n"
"  Filter: (name &= 'gr-oonga'::text)\n"
"(2 rows)"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:135
msgid "SELECT name\n"
"  FROM tags\n"
" WHERE name &= 'gr-oonga';\n"
" name \n"
"------\n"
"(0 rows)\n"
"```"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:143
msgid "On the other hand, if we use the second syntax, we can exact match search with custom normalizer even if PGroonga's index is not used."
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:151
msgid "CREATE INDEX pgrn_index ON tags\n"
"  USING pgroonga (name pgroonga_text_term_search_ops_v2);"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:163
msgid "EXPLAIN (COSTS OFF)\n"
"SELECT name\n"
"  FROM tags\n"
" WHERE name &= ('groonga', NULL, 'pgrn_index')::pgroonga_full_text_search_condition\n"
" ORDER BY id;\n"
"QUERY PLAN\n"
"Sort\n"
"  Sort Key: id\n"
"  ->  Seq Scan on tags\n"
"        Filter: (name &= '(groonga,,pgrn_index)'::pgroonga_full_text_search_condition)\n"
"(4 rows)"
msgstr ""

#: ../../../../reference/operators/exact-match-search.md:175
msgid "SELECT name\n"
"  FROM tags\n"
" WHERE name &= ('groonga', NULL, 'pgrn_index')::pgroonga_full_text_search_condition\n"
" ORDER BY id;\n"
"  name   \n"
"---------\n"
" Groonga\n"
" groonga\n"
"(2 rows)\n"
"```"
msgstr ""

